该算法用于确定一组数的质数
从2到n全假定为质数，针对每一个质数i，都将它的倍数设置为非质数（倍数范围从i*2、i*3一直到<=n），最终就能确定这组数中的所有质数
质数的定义是除了1和它本身没有其他因素的自然数，换句话说，非质数n就是（1，n）中存在因数的数。
非质数n，假定根号n是它的一个因数，那么另一个成对的因数也是根号n。其余因数对中的因数一个小于根号n一个大于根号n。
常见的确定质数方法也由此而来，判断[2,根号n]中是否存在因数。
那么这种新算法为什么正确？
如果我们要确定n是否是质数，只需要观察[2,根号n]中是否存在它的因数，我们可以把这个范围的数分为两类，一类是2357这种质数，一类是由这种质数充当因数的非质数。
如果n是非质数，那么[2,根号n]中必然存在它的因数，而这范围中的质数一定是它们所有人的因数。
然而在这种筛法中，每发现一个质数，都已经将它的倍数设置成了非质数，也就是说非质数的已经完全被划掉了，所以这种算法是正确的。
代码如下
int countPrimes(int n) {
        if(n<3) return 0;
        int flag[n];//2
        int ans=0;
        flag[0]=0;
        flag[1]=0;
        for(int i=2;i<n;i++) flag[i]=1;
        for(int i=2;i<n;i++){
            if(flag[i]==1){
                ans++;
                int j=i;
                int k=2;
                while(j*k<n){
                    flag[j*k]=0;
                    k++;
                }
            }
        }
        return ans;
    }
关于数组赋初值，{}并不能用于整体赋值，{1，2，3，4，5}才是常见的使用方法。0是编译器给赋值的。
